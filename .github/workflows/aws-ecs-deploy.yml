# TalentRadar Config Server - AWS ECS Deployment Workflow
# This workflow builds and deploys the Config Server to Amazon ECS when there's a merge to development, staging, or production branches

name: Deploy Config Server to AWS ECS

on:
  push:
    branches: ["development", "staging", "production"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "development"
        type: choice
        options:
          - development
          - staging
          - production

permissions:
  contents: read
  id-token: write # Required for requesting the JWT

jobs:
  set-environment:
    name: Set Environment Variables
    runs-on: ubuntu-latest
    outputs:
      env_name: ${{ steps.set-env.outputs.env_name }}
      aws_region: ${{ steps.set-env.outputs.aws_region }}
      ecr_repository: ${{ steps.set-env.outputs.ecr_repository }}
      ecr_registry: ${{ steps.set-env.outputs.ecr_registry }}
      ecs_service: ${{ steps.set-env.outputs.ecs_service }}
      ecs_cluster: ${{ steps.set-env.outputs.ecs_cluster }}
      task_definition: ${{ steps.set-env.outputs.task_definition }}
      container_name: ${{ steps.set-env.outputs.container_name }}

    steps:
      - name: Determine environment
        id: set-env
        run: |
          # Determine environment based on branch or manual input
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          else
            if [ "${{ github.ref }}" == "refs/heads/development" ]; then
              ENV_NAME="development"
            elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
              ENV_NAME="staging"
            elif [ "${{ github.ref }}" == "refs/heads/production" ]; then
              ENV_NAME="production"
            else
              ENV_NAME="development"  # Default
            fi
          fi

          # Set common variables from GitHub secrets
          AWS_REGION="${{ secrets.AWS_REGION }}"
          ECR_REPOSITORY="${{ secrets.ECR_REPOSITORY }}"
          ECR_REGISTRY="${{ secrets.ECR_REGISTRY }}"
          CONTAINER_NAME="${{ secrets.CONTAINER_NAME }}"

          # ECS Configuration from secrets
          ECS_CLUSTER="${{ secrets.ECS_CLUSTER }}"
          ECS_SERVICE="${{ secrets.ECS_SERVICE }}"

          # Create task definition directory if it doesn't exist
          mkdir -p .aws

          # Create task definition file using jq for proper JSON handling
          jq -n \
            --arg family "TalentRadar-config-server" \
            --arg execution_role "arn:aws:iam::323135480621:role/TalentRadar-ECSTaskExecutionRole" \
            --arg task_role "arn:aws:iam::323135480621:role/TalentRadar-ECSTaskRole" \
            --arg container_name "config-server" \
            --arg image "${ECR_REGISTRY}/${ECR_REPOSITORY}:latest" \
            --arg env_name "${ENV_NAME}" \
            --arg aws_region "${AWS_REGION}" \
            '{
              family: $family,
              executionRoleArn: $execution_role,
              taskRoleArn: $task_role,
              networkMode: "awsvpc",
              requiresCompatibilities: ["FARGATE"],
              cpu: "256",
              memory: "512",
              tags: [],
              containerDefinitions: [
                {
                  name: $container_name,
                  image: $image,
                  essential: true,
                  portMappings: [
                    {
                      containerPort: 8085,
                      protocol: "tcp"
                    }
                  ],
                  environment: [
                    {
                      name: "SPRING_PROFILES_ACTIVE",
                      value: $env_name
                    },
                    {
                      name: "SERVER_PORT",
                      value: "8085"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_URI",
                      value: "https://github.com/AmaliTech-Training-Academy/talentradar-config-repo-rw"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_DEFAULT_LABEL",
                      value: "main"
                    },
                    {
                      name: "SERVICE_NAME",
                      value: "config-server"
                    }
                  ],
                  logConfiguration: {
                    logDriver: "awslogs",
                    options: {
                      "awslogs-group": "/aws/ecs/talentradar",
                      "awslogs-region": $aws_region,
                      "awslogs-stream-prefix": "ecs"
                    }
                  },
                  healthCheck: {
                    command: [
                      "CMD-SHELL",
                      "curl -f http://localhost:8085/actuator/health || exit 1"
                    ],
                    interval: 30,
                    timeout: 5,
                    retries: 3,
                    startPeriod: 60
                  }
                }
              ]
            }' > .aws/task-definition-${ENV_NAME}.json

          # Output all variables
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "aws_region=${AWS_REGION}" >> $GITHUB_OUTPUT
          echo "ecr_repository=${ECR_REPOSITORY}" >> $GITHUB_OUTPUT
          echo "ecr_registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "ecs_service=${ECS_SERVICE}" >> $GITHUB_OUTPUT
          echo "ecs_cluster=${ECS_CLUSTER}" >> $GITHUB_OUTPUT
          echo "task_definition=.aws/task-definition-${ENV_NAME}.json" >> $GITHUB_OUTPUT
          echo "container_name=${CONTAINER_NAME}" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: set-environment
    environment: ${{ needs.set-environment.outputs.env_name }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
      ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
      ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
      TASK_DEFINITION: ${{ needs.set-environment.outputs.task_definition }}
      CONTAINER_NAME: ${{ secrets.CONTAINER_NAME }}
      ENV_NAME: ${{ needs.set-environment.outputs.env_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        run: |
          # Build a docker container with latest tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:latest \
            --build-arg SPRING_PROFILES_ACTIVE=$ENV_NAME \
            .

          # Push only the latest tag
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:latest" >> $GITHUB_OUTPUT

      - name: Clean up old ECR images (keep only latest)
        run: |
          # List all images except the latest one
          OLD_IMAGES=$(aws ecr list-images --repository-name $ECR_REPOSITORY --region $AWS_REGION \
            --filter tagStatus=TAGGED \
            --query 'imageIds[?imageTag!=`latest`]' \
            --output json)

          # Delete old images if any exist
          if [ "$OLD_IMAGES" != "[]" ] && [ "$OLD_IMAGES" != "null" ]; then
            echo "Deleting old images..."
            aws ecr batch-delete-image --repository-name $ECR_REPOSITORY --region $AWS_REGION --image-ids "$OLD_IMAGES" || true
            echo "Old images cleaned up"
          else
            echo "No old images to clean up"
          fi

      - name: Fill in the new image ID in the Amazon ECS task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: ${{ env.TASK_DEFINITION }}
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ steps.build-image.outputs.image }}

      - name: Debug task definition
        run: |
          echo "Task definition file contents:"
          cat ${{ steps.task-def.outputs.task-definition }}
          echo ""
          echo "Validating JSON format..."
          jq empty ${{ steps.task-def.outputs.task-definition }} && echo "✅ Valid JSON" || echo "❌ Invalid JSON"

      - name: Deploy Amazon ECS task definition
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
        continue-on-error: true
        id: deploy-attempt-1

      - name: Retry ECS deployment if first attempt failed
        if: steps.deploy-attempt-1.outcome == 'failure'
        run: |
          echo "First deployment attempt failed, retrying in 30 seconds..."
          sleep 30

          # Manual deployment using AWS CLI as fallback
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://${{ env.TASK_DEFINITION }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          echo "Registered task definition: $TASK_DEF_ARN"

          # Update the service
          aws ecs update-service \
            --cluster ${{ env.ECS_CLUSTER }} \
            --service ${{ env.ECS_SERVICE }} \
            --task-definition $TASK_DEF_ARN \
            --region ${{ env.AWS_REGION }}

          echo "Service update initiated"

          # Wait for deployment to complete
          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }}

      - name: Post-deployment verification
        run: |
          echo "Waiting for deployment to stabilize..."
          sleep 30

          # Check service status
          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION

          echo "Deployment completed for $ENV_NAME environment"
