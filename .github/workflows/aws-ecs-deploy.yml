# TalentRadar Config Server - AWS ECS Deployment Workflow
# This workflow builds and deploys the Config Server to Amazon ECS when there's a merge to development, staging, or production branches

name: Deploy Config Server to AWS ECS

on:
  push:
    branches: ["development", "staging", "production"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "development"
        type: choice
        options:
          - development
          - staging
          - production

permissions:
  contents: read
  id-token: write # Required for requesting the JWT

jobs:
  set-environment:
    name: Set Environment Variables
    runs-on: ubuntu-latest
    outputs:
      env_name: ${{ steps.set-env.outputs.env_name }}
      aws_region: ${{ steps.set-env.outputs.aws_region }}
      ecr_repository: ${{ steps.set-env.outputs.ecr_repository }}
      ecr_registry: ${{ steps.set-env.outputs.ecr_registry }}
      ecs_service: ${{ steps.set-env.outputs.ecs_service }}
      ecs_cluster: ${{ steps.set-env.outputs.ecs_cluster }}
      task_definition: ${{ steps.set-env.outputs.task_definition }}
      container_name: ${{ steps.set-env.outputs.container_name }}

    steps:
      - name: Determine environment
        id: set-env
        run: |
          # Determine environment based on branch or manual input
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          else
            if [ "${{ github.ref }}" == "refs/heads/development" ]; then
              ENV_NAME="development"
            elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
              ENV_NAME="staging"
            elif [ "${{ github.ref }}" == "refs/heads/production" ]; then
              ENV_NAME="production"
            else
              ENV_NAME="development"  # Default
            fi
          fi

          # Set common variables from GitHub secrets
          AWS_REGION="${{ secrets.AWS_REGION }}"
          ECR_REPOSITORY="${{ secrets.ECR_REPOSITORY }}"
          ECR_REGISTRY="${{ secrets.ECR_REGISTRY }}"
          CONTAINER_NAME="${{ secrets.CONTAINER_NAME }}"

          # ECS Configuration from secrets
          ECS_CLUSTER="${{ secrets.ECS_CLUSTER }}"
          ECS_SERVICE="${{ secrets.ECS_SERVICE }}"

          # Create task definition directory if it doesn't exist
          mkdir -p .aws

          # Create task definition file using jq for proper JSON handling
          jq -n \
            --arg family "TalentRadar-config-server" \
            --arg execution_role "arn:aws:iam::323135480621:role/TalentRadar-ECSTaskExecutionRole" \
            --arg task_role "arn:aws:iam::323135480621:role/TalentRadar-ECSTaskRole" \
            --arg container_name "config-server" \
            --arg image_placeholder "PLACEHOLDER_IMAGE_URI" \
            --arg env_name "${ENV_NAME}" \
            --arg aws_region "${AWS_REGION}" \
            '{
              family: $family,
              executionRoleArn: $execution_role,
              taskRoleArn: $task_role,
              networkMode: "awsvpc",
              requiresCompatibilities: ["FARGATE"],
              cpu: "256",
              memory: "512",
              tags: [],
              containerDefinitions: [
                {
                  name: $container_name,
                  image: $image_placeholder,
                  essential: true,
                  portMappings: [
                    {
                      containerPort: 8085,
                      protocol: "tcp"
                    }
                  ],
                  environment: [
                    {
                      name: "SPRING_PROFILES_ACTIVE",
                      value: $env_name
                    },
                    {
                      name: "SERVER_PORT",
                      value: "8085"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_URI",
                      value: "https://github.com/AmaliTech-Training-Academy/talentradar-config-repo-rw"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_DEFAULT_LABEL",
                      value: "main"
                    },
                    {
                      name: "SERVICE_NAME",
                      value: "config-server"
                    }
                  ],
                  logConfiguration: {
                    logDriver: "awslogs",
                    options: {
                      "awslogs-group": "/aws/ecs/talentradar",
                      "awslogs-region": $aws_region,
                      "awslogs-stream-prefix": "ecs"
                    }
                  },
                  healthCheck: {
                    command: [
                      "CMD-SHELL",
                      "curl -f http://localhost:8085/actuator/health || exit 1"
                    ],
                    interval: 30,
                    timeout: 5,
                    retries: 3,
                    startPeriod: 60
                  }
                }
              ]
            }' > .aws/task-definition-${ENV_NAME}.json

          # Output all variables
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "aws_region=${AWS_REGION}" >> $GITHUB_OUTPUT
          echo "ecr_repository=${ECR_REPOSITORY}" >> $GITHUB_OUTPUT
          echo "ecr_registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "ecs_service=${ECS_SERVICE}" >> $GITHUB_OUTPUT
          echo "ecs_cluster=${ECS_CLUSTER}" >> $GITHUB_OUTPUT
          echo "task_definition=.aws/task-definition-${ENV_NAME}.json" >> $GITHUB_OUTPUT
          echo "container_name=${CONTAINER_NAME}" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: set-environment
    environment: ${{ needs.set-environment.outputs.env_name }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
      ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
      ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
      TASK_DEFINITION: ${{ needs.set-environment.outputs.task_definition }}
      CONTAINER_NAME: ${{ secrets.CONTAINER_NAME }}
      ENV_NAME: ${{ needs.set-environment.outputs.env_name }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          retry-max-attempts: 3

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Check ECR repository configuration
        run: |
          echo "=== ECR Repository Information ==="
          aws ecr describe-repositories \
            --repository-names $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query 'repositories[0].{Name:repositoryName,ImageTagMutability:imageTagMutability,RepositoryUri:repositoryUri}' \
            --output table

          echo ""
          echo "Current images in repository:"
          aws ecr list-images \
            --repository-name $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query 'imageIds[*].imageTag' \
            --output table || echo "No existing images found"

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        run: |
          # Create unique tag using timestamp and commit SHA
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          COMMIT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          UNIQUE_TAG="${ENV_NAME}-${TIMESTAMP}-${COMMIT_SHA}"

          echo "Building image with unique tag: $UNIQUE_TAG"

          # Build docker container with unique tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG \
            --build-arg SPRING_PROFILES_ACTIVE=$ENV_NAME \
            .

          # Also tag as latest for local reference
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

          # Push the unique tag (this will always work with immutable repos)
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG

          # Try to push latest, but don't fail if it already exists
          echo "Attempting to push latest tag (may fail if immutable)..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest || echo "Latest tag push failed (likely immutable repo) - continuing with unique tag"

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG" >> $GITHUB_OUTPUT
          echo "unique_tag=$UNIQUE_TAG" >> $GITHUB_OUTPUT

      - name: Clean up old ECR images (keep latest 5 per environment)
        run: |
          echo "Cleaning up old ECR images for environment: $ENV_NAME"

          # Get all images for this environment using a simpler approach
          echo "Fetching images for environment: $ENV_NAME"

          # First, get all image tags that match our environment pattern
          ENV_TAGS=$(aws ecr list-images \
            --repository-name $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query "imageIds[?starts_with(imageTag, '$ENV_NAME-')].imageTag" \
            --output text)

          if [ -z "$ENV_TAGS" ] || [ "$ENV_TAGS" = "None" ]; then
            echo "No images found for environment: $ENV_NAME"
          else
            echo "Found images for environment $ENV_NAME:"
            echo "$ENV_TAGS"
            
            # Count how many images we have
            IMAGE_COUNT=$(echo "$ENV_TAGS" | wc -w)
            echo "Total images for $ENV_NAME: $IMAGE_COUNT"
            
            # If we have more than 5 images, delete the oldest ones
            if [ "$IMAGE_COUNT" -gt 5 ]; then
              echo "Need to clean up $(($IMAGE_COUNT - 5)) old images"
              
              # Sort tags by timestamp (they include timestamp in format YYYYMMDD-HHMMSS)
              # Keep only the 5 newest, delete the rest
              TAGS_TO_DELETE=$(echo "$ENV_TAGS" | tr ' ' '\n' | sort | head -n $(($IMAGE_COUNT - 5)))
              
              if [ ! -z "$TAGS_TO_DELETE" ]; then
                echo "Tags to delete:"
                echo "$TAGS_TO_DELETE"
                
                # Delete each tag
                for tag in $TAGS_TO_DELETE; do
                  echo "Deleting image with tag: $tag"
                  aws ecr batch-delete-image \
                    --repository-name $ECR_REPOSITORY \
                    --region $AWS_REGION \
                    --image-ids imageTag=$tag || echo "Failed to delete $tag (continuing...)"
                done
                echo "✅ Cleanup completed"
              fi
            else
              echo "Only $IMAGE_COUNT images found, no cleanup needed (keeping up to 5)"
            fi
          fi

      - name: Update task definition with new image
        run: |
          echo "=== Task Definition Update ==="
          echo "Environment: $ENV_NAME"
          echo "Image URI: ${{ steps.build-image.outputs.image }}"
          echo "Unique Tag: ${{ steps.build-image.outputs.unique_tag }}"
          echo ""

          # Replace the placeholder with the actual image URI
          sed -i "s|PLACEHOLDER_IMAGE_URI|${{ steps.build-image.outputs.image }}|g" ${{ env.TASK_DEFINITION }}

          echo "✅ Updated task definition with image: ${{ steps.build-image.outputs.image }}"
          echo ""
          echo "=== Task Definition Contents ==="
          cat ${{ env.TASK_DEFINITION }}
          echo ""
          echo "=== JSON Validation ==="
          jq empty ${{ env.TASK_DEFINITION }} && echo "✅ Valid JSON" || echo "❌ Invalid JSON"

      - name: Deploy Amazon ECS task definition with retry logic
        id: deploy-ecs
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ env.TASK_DEFINITION }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 10
          force-new-deployment: false
        env:
          AWS_RETRY_MODE: adaptive
          AWS_MAX_ATTEMPTS: 3
        continue-on-error: true

      - name: Fallback deployment using AWS CLI (if GitHub Action fails)
        if: steps.deploy-ecs.outcome == 'failure'
        run: |
          echo "GitHub Action deployment failed, falling back to AWS CLI..."
          echo "Waiting 30 seconds before retry..."
          sleep 30

          # Register the task definition directly using the updated file
          echo "Registering task definition..."
          TASK_DEF_ARN=$(aws ecs register-task-definition \
            --cli-input-json file://${{ env.TASK_DEFINITION }} \
            --region ${{ env.AWS_REGION }} \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)

          if [ -z "$TASK_DEF_ARN" ]; then
            echo "❌ Failed to register task definition"
            exit 1
          fi

          echo "✅ Registered task definition: $TASK_DEF_ARN"

          # Update the service with retry logic
          for attempt in 1 2 3; do
            echo "Attempting service update (attempt $attempt/3)..."
            
            if aws ecs update-service \
              --cluster ${{ env.ECS_CLUSTER }} \
              --service ${{ env.ECS_SERVICE }} \
              --task-definition "$TASK_DEF_ARN" \
              --region ${{ env.AWS_REGION }}; then
              
              echo "✅ Service update successful"
              break
            else
              echo "❌ Service update failed (attempt $attempt/3)"
              if [ $attempt -eq 3 ]; then
                echo "All attempts failed"
                exit 1
              fi
              echo "Waiting 60 seconds before retry..."
              sleep 60
            fi
          done

          # Wait for deployment to stabilize
          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster ${{ env.ECS_CLUSTER }} \
            --services ${{ env.ECS_SERVICE }} \
            --region ${{ env.AWS_REGION }} \
            --cli-read-timeout 600 \
            --cli-connect-timeout 60

          echo "✅ Deployment completed successfully using AWS CLI fallback"

      - name: Verify deployment success
        run: |
          # Final verification
          if [ "${{ steps.deploy-ecs.outcome }}" = "success" ]; then
            echo "✅ Deployment completed successfully using GitHub Actions"
          elif [ "${{ steps.deploy-ecs.outcome }}" = "failure" ]; then
            echo "✅ Deployment completed successfully using AWS CLI fallback"
          else
            echo "❌ Deployment status unknown"
            exit 1
          fi

      - name: Post-deployment verification
        run: |
          echo "Waiting for deployment to stabilize..."
          sleep 30

          # Check service status
          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION

          echo "Deployment completed for $ENV_NAME environment"
