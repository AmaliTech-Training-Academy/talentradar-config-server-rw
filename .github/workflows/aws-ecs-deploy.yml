# TalentRadar Config Server - AWS ECS Deployment Workflow
# This workflow builds and deploys the Config Server to Amazon ECS when there's a merge to development, staging, or production branches

name: Deploy Config Server to AWS ECS

on:
  push:
    branches: ["development", "staging", "production"]
  workflow_dispatch:
    inputs:
      environment:
        description: "Environment to deploy to"
        required: true
        default: "development"
        type: choice
        options:
          - development
          - staging
          - production

permissions:
  contents: read
  id-token: write # Required for requesting the JWT

jobs:
  set-environment:
    name: Set Environment Variables
    runs-on: ubuntu-latest
    outputs:
      env_name: ${{ steps.set-env.outputs.env_name }}
      aws_region: ${{ steps.set-env.outputs.aws_region }}
      ecr_repository: ${{ steps.set-env.outputs.ecr_repository }}
      ecr_registry: ${{ steps.set-env.outputs.ecr_registry }}
      ecs_service: ${{ steps.set-env.outputs.ecs_service }}
      ecs_cluster: ${{ steps.set-env.outputs.ecs_cluster }}
      task_definition: ${{ steps.set-env.outputs.task_definition }}
      container_name: ${{ steps.set-env.outputs.container_name }}

    steps:
      - name: Determine environment
        id: set-env
        run: |
          # Determine environment based on branch or manual input
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            ENV_NAME="${{ github.event.inputs.environment }}"
          else
            if [ "${{ github.ref }}" == "refs/heads/development" ]; then
              ENV_NAME="development"
            elif [ "${{ github.ref }}" == "refs/heads/staging" ]; then
              ENV_NAME="staging"
            elif [ "${{ github.ref }}" == "refs/heads/production" ]; then
              ENV_NAME="production"
            else
              ENV_NAME="development"  # Default
            fi
          fi

          # Set common variables from GitHub secrets
          AWS_REGION="${{ secrets.AWS_REGION }}"
          ECR_REPOSITORY="${{ secrets.ECR_REPOSITORY }}"
          ECR_REGISTRY="${{ secrets.ECR_REGISTRY }}"
          CONTAINER_NAME="${{ secrets.CONTAINER_NAME }}"

          # ECS Configuration from secrets
          ECS_CLUSTER="${{ secrets.ECS_CLUSTER }}"
          ECS_SERVICE="${{ secrets.ECS_SERVICE }}"

          # Create task definition directory if it doesn't exist
          mkdir -p .aws

          # Create task definition file using jq for proper JSON handling
          jq -n \
            --arg family "TalentRadar-config-server" \
            --arg execution_role "arn:aws:iam::323135480621:role/TalentRadar-ECSTaskExecutionRole" \
            --arg task_role "arn:aws:iam::323135480621:role/TalentRadar-ECSTaskRole" \
            --arg container_name "config-server" \
            --arg image_placeholder "PLACEHOLDER_IMAGE_URI" \
            --arg env_name "${ENV_NAME}" \
            --arg aws_region "${AWS_REGION}" \
            '{
              family: $family,
              executionRoleArn: $execution_role,
              taskRoleArn: $task_role,
              networkMode: "awsvpc",
              requiresCompatibilities: ["FARGATE"],
              cpu: "256",
              memory: "512",
              containerDefinitions: [
                {
                  name: $container_name,
                  image: $image_placeholder,
                  essential: true,
                  portMappings: [
                    {
                      containerPort: 8085,
                      protocol: "tcp"
                    }
                  ],
                  environment: [
                    {
                      name: "SPRING_PROFILES_ACTIVE",
                      value: $env_name
                    },
                    {
                      name: "SERVER_PORT",
                      value: "8085"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_URI",
                      value: "https://github.com/AmaliTech-Training-Academy/talentradar-config-repo-rw"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_DEFAULT_LABEL",
                      value: "main"
                    },
                    {
                      name: "SERVICE_NAME",
                      value: "config-server"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_USERNAME",
                      value: "git"
                    },
                    {
                      name: "SPRING_CLOUD_CONFIG_SERVER_GIT_PASSWORD",
                      value: "${{ secrets.GITHUB_TOKEN }}"
                    }
                  ],
                  logConfiguration: {
                    logDriver: "awslogs",
                    options: {
                      "awslogs-group": "/aws/ecs/talentradar",
                      "awslogs-region": $aws_region,
                      "awslogs-stream-prefix": "ecs"
                    }
                  },
                  healthCheck: {
                    command: [
                      "CMD-SHELL",
                      "curl -f http://localhost:8085/actuator/health || exit 1"
                    ],
                    interval: 30,
                    timeout: 5,
                    retries: 3,
                    startPeriod: 60
                  }
                }
              ]
            }' > .aws/task-definition-${ENV_NAME}.json

          # Output all variables
          echo "env_name=${ENV_NAME}" >> $GITHUB_OUTPUT
          echo "aws_region=${AWS_REGION}" >> $GITHUB_OUTPUT
          echo "ecr_repository=${ECR_REPOSITORY}" >> $GITHUB_OUTPUT
          echo "ecr_registry=${ECR_REGISTRY}" >> $GITHUB_OUTPUT
          echo "ecs_service=${ECS_SERVICE}" >> $GITHUB_OUTPUT
          echo "ecs_cluster=${ECS_CLUSTER}" >> $GITHUB_OUTPUT
          echo "task_definition=.aws/task-definition-${ENV_NAME}.json" >> $GITHUB_OUTPUT
          echo "container_name=${CONTAINER_NAME}" >> $GITHUB_OUTPUT

  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: set-environment
    environment: ${{ needs.set-environment.outputs.env_name }}
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
      ECS_SERVICE: ${{ secrets.ECS_SERVICE }}
      ECS_CLUSTER: ${{ secrets.ECS_CLUSTER }}
      TASK_DEFINITION: ${{ needs.set-environment.outputs.task_definition }}
      CONTAINER_NAME: ${{ secrets.CONTAINER_NAME }}
      ENV_NAME: ${{ needs.set-environment.outputs.env_name }}
      AWS_RETRY_MODE: adaptive
      AWS_MAX_ATTEMPTS: 5

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
          retry-max-attempts: 5

      - name: Test AWS permissions and connectivity
        run: |
          echo "=== Testing AWS Permissions and Connectivity ==="

          # Test basic AWS connectivity
          echo "1. Testing AWS STS (Security Token Service)..."
          aws sts get-caller-identity --region $AWS_REGION || {
            echo "❌ Failed to get AWS caller identity"
            exit 1
          }

          echo "2. Testing ECR permissions..."
          aws ecr describe-repositories --repository-names $ECR_REPOSITORY --region $AWS_REGION > /dev/null || {
            echo "❌ Failed to access ECR repository: $ECR_REPOSITORY"
            exit 1
          }

          echo "3. Testing ECS permissions..."
          aws ecs describe-clusters --clusters $ECS_CLUSTER --region $AWS_REGION > /dev/null || {
            echo "❌ Failed to access ECS cluster: $ECS_CLUSTER"
            exit 1
          }

          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION > /dev/null || {
            echo "❌ Failed to access ECS service: $ECS_SERVICE"
            exit 1
          }

          echo "4. Testing IAM permissions for ECS task definitions..."
          aws ecs list-task-definitions --region $AWS_REGION --max-items 1 > /dev/null || {
            echo "❌ Failed to list task definitions"
            exit 1
          }

          echo "✅ All AWS permissions and connectivity tests passed"

          # Show current AWS service health (if available)
          echo ""
          echo "=== AWS Service Information ==="
          echo "AWS Region: $AWS_REGION"
          echo "Current AWS Identity:"
          aws sts get-caller-identity --region $AWS_REGION

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Check ECR repository configuration
        run: |
          echo "=== ECR Repository Information ==="
          aws ecr describe-repositories \
            --repository-names $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query 'repositories[0].{Name:repositoryName,ImageTagMutability:imageTagMutability,RepositoryUri:repositoryUri}' \
            --output table

          echo ""
          echo "Current images in repository:"
          aws ecr list-images \
            --repository-name $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query 'imageIds[*].imageTag' \
            --output table || echo "No existing images found"

      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        run: |
          # Create unique tag using timestamp and commit SHA
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          COMMIT_SHA=$(echo ${{ github.sha }} | cut -c1-8)
          UNIQUE_TAG="${ENV_NAME}-${TIMESTAMP}-${COMMIT_SHA}"

          echo "Building image with unique tag: $UNIQUE_TAG"

          # Build docker container with unique tag
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG \
            --build-arg SPRING_PROFILES_ACTIVE=$ENV_NAME \
            .

          # Also tag as latest for local reference
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

          # Push with enhanced retry logic
          echo "Pushing image with retry logic..."
          for attempt in 1 2 3 4 5; do
            echo "Push attempt $attempt/5 for unique tag: $UNIQUE_TAG"
            
            if docker push $ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG; then
              echo "✅ Successfully pushed unique tag on attempt $attempt"
              break
            else
              echo "❌ Push failed on attempt $attempt"
              if [ $attempt -eq 5 ]; then
                echo "❌ All push attempts failed"
                exit 1
              fi
              echo "Waiting 30 seconds before retry..."
              sleep 30
            fi
          done

          # Try to push latest, but don't fail if it already exists
          echo "Attempting to push latest tag (may fail if immutable)..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest || echo "Latest tag push failed (likely immutable repo) - continuing with unique tag"

          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$UNIQUE_TAG" >> $GITHUB_OUTPUT
          echo "unique_tag=$UNIQUE_TAG" >> $GITHUB_OUTPUT

      - name: Clean up old ECR images (keep latest 5 per environment)
        run: |
          echo "Cleaning up old ECR images for environment: $ENV_NAME"

          # Get all images for this environment using a simpler approach
          echo "Fetching images for environment: $ENV_NAME"

          # First, get all image tags that match our environment pattern
          ENV_TAGS=$(aws ecr list-images \
            --repository-name $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query "imageIds[?starts_with(imageTag, '$ENV_NAME-')].imageTag" \
            --output text)

          if [ -z "$ENV_TAGS" ] || [ "$ENV_TAGS" = "None" ]; then
            echo "No images found for environment: $ENV_NAME"
          else
            echo "Found images for environment $ENV_NAME:"
            echo "$ENV_TAGS"
            
            # Count how many images we have
            IMAGE_COUNT=$(echo "$ENV_TAGS" | wc -w)
            echo "Total images for $ENV_NAME: $IMAGE_COUNT"
            
            # If we have more than 5 images, delete the oldest ones
            if [ "$IMAGE_COUNT" -gt 5 ]; then
              echo "Need to clean up $(($IMAGE_COUNT - 5)) old images"
              
              # Sort tags by timestamp (they include timestamp in format YYYYMMDD-HHMMSS)
              # Keep only the 5 newest, delete the rest
              TAGS_TO_DELETE=$(echo "$ENV_TAGS" | tr ' ' '\n' | sort | head -n $(($IMAGE_COUNT - 5)))
              
              if [ ! -z "$TAGS_TO_DELETE" ]; then
                echo "Tags to delete:"
                echo "$TAGS_TO_DELETE"
                
                # Delete each tag
                for tag in $TAGS_TO_DELETE; do
                  echo "Deleting image with tag: $tag"
                  aws ecr batch-delete-image \
                    --repository-name $ECR_REPOSITORY \
                    --region $AWS_REGION \
                    --image-ids imageTag=$tag || echo "Failed to delete $tag (continuing...)"
                done
                echo "✅ Cleanup completed"
              fi
            else
              echo "Only $IMAGE_COUNT images found, no cleanup needed (keeping up to 5)"
            fi
          fi

      - name: Update task definition with new image
        run: |
          echo "=== Task Definition Update ==="
          echo "Environment: $ENV_NAME"
          echo "Image URI: ${{ steps.build-image.outputs.image }}"
          echo "Unique Tag: ${{ steps.build-image.outputs.unique_tag }}"
          echo ""

          # Replace the placeholder with the actual image URI
          sed -i "s|PLACEHOLDER_IMAGE_URI|${{ steps.build-image.outputs.image }}|g" ${{ env.TASK_DEFINITION }}

          echo "✅ Updated task definition with image: ${{ steps.build-image.outputs.image }}"
          echo ""
          echo "=== Task Definition Contents ==="
          cat ${{ env.TASK_DEFINITION }}
          echo ""
          echo "=== JSON Validation ==="
          jq empty ${{ env.TASK_DEFINITION }} && echo "✅ Valid JSON" || echo "❌ Invalid JSON"

      - name: Deploy Amazon ECS task definition with enhanced retry logic
        id: deploy-ecs
        uses: aws-actions/amazon-ecs-deploy-task-definition@v2
        with:
          task-definition: ${{ env.TASK_DEFINITION }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
          wait-for-minutes: 15
          force-new-deployment: false
        env:
          AWS_RETRY_MODE: adaptive
          AWS_MAX_ATTEMPTS: 5
        continue-on-error: true

      - name: Enhanced AWS CLI fallback deployment with comprehensive retry
        if: steps.deploy-ecs.outcome == 'failure'
        run: |
          echo "=== AWS CLI Fallback Deployment ==="
          echo "GitHub Action deployment failed, using enhanced AWS CLI fallback..."

          # Pre-deployment checks
          echo "1. Checking AWS service availability..."
          for attempt in 1 2 3; do
            if aws sts get-caller-identity --region $AWS_REGION > /dev/null 2>&1; then
              echo "✅ AWS services accessible on attempt $attempt"
              break
            else
              echo "❌ AWS services not accessible on attempt $attempt"
              if [ $attempt -eq 3 ]; then
                echo "❌ AWS services unavailable after 3 attempts"
                exit 1
              fi
              sleep 30
            fi
          done

          # Wait before attempting deployment
          echo "2. Waiting 60 seconds for service stabilization..."
          sleep 60

          # Register the task definition with enhanced error handling
          echo "3. Registering task definition..."

          # Validate task definition JSON first
          if ! jq empty "$TASK_DEFINITION"; then
            echo "❌ Task definition JSON is invalid"
            cat "$TASK_DEFINITION"
            exit 1
          fi

          for reg_attempt in 1 2 3 4 5; do
            echo "Task definition registration attempt $reg_attempt/5..."
            
            TASK_DEF_ARN=$(aws ecs register-task-definition \
              --cli-input-json file://"$TASK_DEFINITION" \
              --region "$AWS_REGION" \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text 2>/dev/null)

            if [ ! -z "$TASK_DEF_ARN" ] && [ "$TASK_DEF_ARN" != "None" ]; then
              echo "✅ Registered task definition on attempt $reg_attempt: $TASK_DEF_ARN"
              break
            else
              echo "❌ Task definition registration failed on attempt $reg_attempt"
              if [ $reg_attempt -eq 5 ]; then
                echo "❌ Failed to register task definition after 5 attempts"
                
                # Debug information
                echo "Task definition content:"
                cat "$TASK_DEFINITION"
                echo ""
                echo "Last AWS CLI error:"
                aws ecs register-task-definition \
                  --cli-input-json file://"$TASK_DEFINITION" \
                  --region "$AWS_REGION" 2>&1 || true
                exit 1
              fi
              
              # Exponential backoff
              sleep_time=$((30 * reg_attempt))
              echo "Waiting ${sleep_time} seconds before retry..."
              sleep $sleep_time
            fi
          done

          # Update the service with enhanced retry logic
          echo "4. Updating ECS service..."
          for svc_attempt in 1 2 3 4 5; do
            echo "Service update attempt $svc_attempt/5..."
            
            if aws ecs update-service \
              --cluster "$ECS_CLUSTER" \
              --service "$ECS_SERVICE" \
              --task-definition "$TASK_DEF_ARN" \
              --region "$AWS_REGION" \
              --force-new-deployment; then
              
              echo "✅ Service update successful on attempt $svc_attempt"
              break
            else
              echo "❌ Service update failed on attempt $svc_attempt"
              if [ $svc_attempt -eq 5 ]; then
                echo "❌ All service update attempts failed"
                exit 1
              fi
              
              # Check service status for debugging
              echo "Current service status:"
              aws ecs describe-services \
                --cluster "$ECS_CLUSTER" \
                --services "$ECS_SERVICE" \
                --region "$AWS_REGION" \
                --query 'services[0].{Status:status,RunningCount:runningCount,PendingCount:pendingCount,DesiredCount:desiredCount}' \
                --output table || true
              
              # Exponential backoff
              sleep_time=$((60 * svc_attempt))
              echo "Waiting ${sleep_time} seconds before retry..."
              sleep $sleep_time
            fi
          done

          # Wait for deployment to stabilize with enhanced monitoring
          echo "5. Waiting for service stabilization..."

          # Use a custom wait with better error handling
          for wait_attempt in 1 2 3; do
            echo "Stability wait attempt $wait_attempt/3..."
            
            if timeout 900 aws ecs wait services-stable \
              --cluster "$ECS_CLUSTER" \
              --services "$ECS_SERVICE" \
              --region "$AWS_REGION"; then
              
              echo "✅ Service stabilized on attempt $wait_attempt"
              break
            else
              echo "❌ Service stabilization failed on attempt $wait_attempt"
              if [ $wait_attempt -eq 3 ]; then
                echo "❌ Service failed to stabilize after 3 attempts"
                
                # Show final service state for debugging
                echo "Final service state:"
                aws ecs describe-services \
                  --cluster "$ECS_CLUSTER" \
                  --services "$ECS_SERVICE" \
                  --region "$AWS_REGION" \
                  --query 'services[0]' \
                  --output json || true
                  
                exit 1
              fi
              echo "Waiting 120 seconds before retry..."
              sleep 120
            fi
          done

          echo "✅ AWS CLI fallback deployment completed successfully"

      - name: Verify deployment success
        run: |
          # Enhanced final verification with detailed service information
          echo "=== Final Deployment Verification ==="

          # Check the deployment method used
          if [ "${{ steps.deploy-ecs.outcome }}" = "success" ]; then
            echo "✅ Deployment completed successfully using GitHub Actions"
          elif [ "${{ steps.deploy-ecs.outcome }}" = "failure" ]; then
            echo "✅ Deployment completed successfully using AWS CLI fallback"
          else
            echo "❌ Deployment status unknown"
            exit 1
          fi

          # Verify service is running correctly
          echo ""
          echo "=== Service Status Verification ==="

          SERVICE_STATUS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --region $AWS_REGION \
            --query 'services[0].{Status:status,RunningCount:runningCount,DesiredCount:desiredCount,TaskDefinition:taskDefinition}' \
            --output json)

          echo "Current service status:"
          echo "$SERVICE_STATUS" | jq .

          # Extract values for validation
          RUNNING_COUNT=$(echo "$SERVICE_STATUS" | jq -r '.RunningCount')
          DESIRED_COUNT=$(echo "$SERVICE_STATUS" | jq -r '.DesiredCount')
          SERVICE_STATUS_VALUE=$(echo "$SERVICE_STATUS" | jq -r '.Status')

          if [ "$RUNNING_COUNT" = "$DESIRED_COUNT" ] && [ "$SERVICE_STATUS_VALUE" = "ACTIVE" ]; then
            echo "✅ Service is healthy: $RUNNING_COUNT/$DESIRED_COUNT tasks running"
          else
            echo "⚠️  Service may not be fully healthy: $RUNNING_COUNT/$DESIRED_COUNT tasks running, status: $SERVICE_STATUS_VALUE"
          fi

          echo ""
          echo "=== Task Information ==="

          # Get task details
          TASKS=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --region $AWS_REGION \
            --query 'taskArns' \
            --output text)

          if [ ! -z "$TASKS" ] && [ "$TASKS" != "None" ]; then
            echo "Active tasks:"
            aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASKS \
              --region $AWS_REGION \
              --query 'tasks[*].{TaskArn:taskArn,LastStatus:lastStatus,HealthStatus:healthStatus,CreatedAt:createdAt}' \
              --output table
          else
            echo "No active tasks found"
          fi

          echo ""
          echo "✅ Deployment verification completed"

      - name: Post-deployment verification
        run: |
          echo "Waiting for deployment to stabilize..."
          sleep 30

          # Check service status
          aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --region $AWS_REGION

          echo "Deployment completed for $ENV_NAME environment"
